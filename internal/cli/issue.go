package cli

import (
	"bufio"
	"fmt"
	"os"
	"os/exec"
	"runtime"
	"strconv"
	"strings"

	"github.com/spf13/cobra"

	"github.com/dulait/grit/internal/config"
	"github.com/dulait/grit/internal/github"
	"github.com/dulait/grit/internal/llm"
	"github.com/dulait/grit/internal/service"
)

var issueCmd = &cobra.Command{
	Use:   "issue",
	Short: "Manage GitHub issues",
}

var (
	flagTitle       string
	flagDescription string
	flagLabels      string
	flagAssignees   string
	flagYes         bool
	flagRaw         bool
	flagEnhance     bool
	linkType        string
	flagState       string
	flagAssignee    string
	flagLabel       string
	flagLimit       int
	flagPage        int
	flagWeb         bool
)

var issueCreateCmd = &cobra.Command{
	Use:   "create [prompt]",
	Short: "Create an issue",
	Long: `Create a GitHub issue. Three modes:

1. Interactive (no args):     grit issue create
2. AI-assisted (prompt):      grit issue create "describe the problem"
3. Explicit (flags):          grit issue create -t "Title" -d "Description"

Flags override AI generation. Missing fields are generated by the LLM.`,
	RunE: runIssueCreate,
}

var issueListCmd = &cobra.Command{
	Use:   "list",
	Short: "List repository issues",
	RunE:  runIssueList,
}

var issueCloseCmd = &cobra.Command{
	Use:   "close <number> [reason]",
	Short: "Close an issue",
	Long:  "Close an issue, optionally with a comment explaining why.",
	Args:  cobra.MinimumNArgs(1),
	RunE:  runIssueClose,
}

var issueCommentCmd = &cobra.Command{
	Use:   "comment <number> <prompt>",
	Short: "Add a comment to an issue",
	Long:  "Generate and add a comment using natural language.",
	Args:  cobra.MinimumNArgs(2),
	RunE:  runIssueComment,
}

var issueAssignCmd = &cobra.Command{
	Use:   "assign <number> <user> [users...]",
	Short: "Assign users to an issue",
	Args:  cobra.MinimumNArgs(2),
	RunE:  runIssueAssign,
}

var issueLinkCmd = &cobra.Command{
	Use:   "link <number> <target-number>",
	Short: "Link two issues",
	Long:  "Create a reference between two issues. Use --type to specify relationship.",
	Args:  cobra.ExactArgs(2),
	RunE:  runIssueLink,
}

var issueViewCmd = &cobra.Command{
	Use:   "view <number>",
	Short: "View an issue",
	Args:  cobra.ExactArgs(1),
	RunE:  runIssueView,
}

var issueEditCmd = &cobra.Command{
	Use:   "edit <number>",
	Short: "Edit an issue",
	Long:  "Edit a GitHub issue's title, description, labels, assignees, or state.",
	Args:  cobra.ExactArgs(1),
	RunE:  runIssueEdit,
}

var issueSubCmd = &cobra.Command{
	Use:   "sub <parent-number> [prompt]",
	Short: "Create a sub-issue",
	Long:  "Create an issue linked as a child of an existing issue.",
	Args:  cobra.MinimumNArgs(1),
	RunE:  runIssueSub,
}

func init() {
	rootCmd.AddCommand(issueCmd)
	issueCmd.AddCommand(issueCreateCmd)
	issueCmd.AddCommand(issueListCmd)
	issueCmd.AddCommand(issueViewCmd)
	issueCmd.AddCommand(issueCloseCmd)
	issueCmd.AddCommand(issueCommentCmd)
	issueCmd.AddCommand(issueAssignCmd)
	issueCmd.AddCommand(issueLinkCmd)
	issueCmd.AddCommand(issueEditCmd)
	issueCmd.AddCommand(issueSubCmd)

	issueCreateCmd.Flags().StringVarP(&flagTitle, "title", "t", "", "Issue title")
	issueCreateCmd.Flags().StringVarP(&flagDescription, "description", "d", "", "Issue description")
	issueCreateCmd.Flags().StringVarP(&flagLabels, "labels", "l", "", "Comma-separated labels")
	issueCreateCmd.Flags().StringVarP(&flagAssignees, "assignees", "a", "", "Comma-separated assignees")
	issueCreateCmd.Flags().BoolVarP(&flagYes, "yes", "y", false, "Skip confirmation prompt")
	issueCreateCmd.Flags().BoolVar(&flagRaw, "raw", false, "Use input verbatim without LLM enhancement")

	issueSubCmd.Flags().StringVarP(&flagTitle, "title", "t", "", "Issue title")
	issueSubCmd.Flags().StringVarP(&flagDescription, "description", "d", "", "Issue description")
	issueSubCmd.Flags().StringVarP(&flagLabels, "labels", "l", "", "Comma-separated labels")
	issueSubCmd.Flags().StringVarP(&flagAssignees, "assignees", "a", "", "Comma-separated assignees")
	issueSubCmd.Flags().BoolVarP(&flagYes, "yes", "y", false, "Skip confirmation prompt")

	issueLinkCmd.Flags().StringVar(&linkType, "type", "related", "Link type: related, blocks, blocked-by, duplicates, parent, child")

	issueViewCmd.Flags().BoolVarP(&flagWeb, "web", "w", false, "Open in browser")

	issueEditCmd.Flags().StringVarP(&flagTitle, "title", "t", "", "New title")
	issueEditCmd.Flags().StringVarP(&flagDescription, "description", "d", "", "New description")
	issueEditCmd.Flags().StringVarP(&flagLabels, "labels", "l", "", "Comma-separated labels (replaces all)")
	issueEditCmd.Flags().StringVarP(&flagAssignees, "assignees", "a", "", "Comma-separated assignees (replaces all)")
	issueEditCmd.Flags().StringVarP(&flagState, "state", "s", "", "New state: open or closed")
	issueEditCmd.Flags().BoolVar(&flagEnhance, "enhance", false, "Enhance changes with LLM")
	issueEditCmd.Flags().BoolVarP(&flagYes, "yes", "y", false, "Skip confirmation")

	issueListCmd.Flags().StringVarP(&flagState, "state", "s", "open", "Filter by state: open, closed, all")
	issueListCmd.Flags().StringVarP(&flagAssignee, "assignee", "a", "", "Filter by assignee, or \"none\" for unassigned")
	issueListCmd.Flags().StringVarP(&flagLabel, "label", "l", "", "Filter by label")
	issueListCmd.Flags().IntVarP(&flagLimit, "limit", "n", 30, "Results per page")
	issueListCmd.Flags().IntVarP(&flagPage, "page", "p", 1, "Page number")
}

func runIssueCreate(cmd *cobra.Command, args []string) error {
	ctx := cmd.Context()

	cfg, err := config.LoadFromWorkingDir()
	if err != nil {
		return err
	}

	input, err := gatherIssueInput(cfg, args)
	if err != nil {
		return err
	}

	enhance := !flagRaw

	ghClient, err := buildGitHubClient(cfg)
	if err != nil {
		return err
	}

	var llmClient llm.Client
	if enhance {
		llmClient, err = buildLLMClient(cfg)
		if err != nil {
			return err
		}
		fmt.Println("Generating issue...")
	}

	svc := service.NewIssueService(ghClient, llmClient, cfg)

	generated, err := svc.GenerateIssue(ctx, input, enhance)
	if err != nil {
		return err
	}

	printGeneratedIssue(generated, input.Assignees)

	if !flagYes {
		if !confirmAction("Create this issue?") {
			fmt.Println("Aborted.")
			return nil
		}
	}

	issue, err := svc.CreateIssue(ctx, generated, input.Assignees)
	if err != nil {
		return err
	}

	fmt.Printf("Created issue #%d: %s\n", issue.Number, issue.HTMLURL)
	return nil
}

func gatherIssueInput(cfg *config.Config, args []string) (service.IssueInput, error) {
	input := service.IssueInput{
		Title:       flagTitle,
		Description: flagDescription,
		Labels:      parseCSV(flagLabels),
		Assignees:   parseCSV(flagAssignees),
	}

	if len(args) > 0 {
		input.Prompt = strings.Join(args, " ")
	}

	hasAnyInput := input.Prompt != "" || input.Title != "" || input.Description != ""

	if !hasAnyInput {
		return runInteractiveMode(cfg)
	}

	if len(input.Labels) > 0 {
		input.Labels = validateLabels(input.Labels, cfg.Project.Labels)
	}

	return input, nil
}

func runInteractiveMode(cfg *config.Config) (service.IssueInput, error) {
	reader := bufio.NewReader(os.Stdin)
	var input service.IssueInput

	fmt.Println("Interactive issue creation (press Enter to skip and let AI generate)")
	fmt.Println()

	title, err := promptOptional(reader, "Title")
	if err != nil {
		return input, err
	}
	input.Title = title

	description, err := promptOptional(reader, "Description")
	if err != nil {
		return input, err
	}
	input.Description = description

	if len(cfg.Project.Labels) > 0 {
		fmt.Printf("Available labels: %s\n", strings.Join(cfg.Project.Labels, ", "))
		labelsStr, err := promptOptional(reader, "Labels (comma-separated)")
		if err != nil {
			return input, err
		}
		if labelsStr != "" {
			input.Labels = validateLabels(parseCSV(labelsStr), cfg.Project.Labels)
		}
	} else {
		fmt.Println("No labels configured. Skipping label selection.")
		fmt.Println("Configure labels in .grit/config.yaml under project.labels")
	}

	assignees, err := promptOptional(reader, "Assignees (comma-separated)")
	if err != nil {
		return input, err
	}
	input.Assignees = parseCSV(assignees)

	if input.Title == "" && input.Description == "" {
		prompt, err := promptOptional(reader, "Describe the issue for AI generation")
		if err != nil {
			return input, err
		}
		input.Prompt = prompt
	}

	if input.Title == "" && input.Description == "" && input.Prompt == "" {
		return input, fmt.Errorf("at least one of title, description, or prompt is required")
	}

	return input, nil
}

func runIssueClose(cmd *cobra.Command, args []string) error {
	ctx := cmd.Context()

	number, err := strconv.Atoi(args[0])
	if err != nil {
		return fmt.Errorf("invalid issue number: %s", args[0])
	}

	var comment string
	if len(args) > 1 {
		comment = strings.Join(args[1:], " ")
	}

	cfg, err := config.LoadFromWorkingDir()
	if err != nil {
		return err
	}

	ghClient, err := buildGitHubClient(cfg)
	if err != nil {
		return err
	}

	svc := service.NewIssueService(ghClient, nil, cfg)

	issue, err := svc.CloseIssue(ctx, number, comment)
	if err != nil {
		return err
	}

	fmt.Printf("Closed issue #%d: %s\n", issue.Number, issue.HTMLURL)
	return nil
}

func runIssueComment(cmd *cobra.Command, args []string) error {
	ctx := cmd.Context()

	number, err := strconv.Atoi(args[0])
	if err != nil {
		return fmt.Errorf("invalid issue number: %s", args[0])
	}

	userPrompt := strings.Join(args[1:], " ")

	cfg, err := config.LoadFromWorkingDir()
	if err != nil {
		return err
	}

	ghClient, err := buildGitHubClient(cfg)
	if err != nil {
		return err
	}

	llmClient, err := buildLLMClient(cfg)
	if err != nil {
		return err
	}

	svc := service.NewIssueService(ghClient, llmClient, cfg)

	fmt.Println("Generating comment...")

	comment, err := svc.AddComment(ctx, number, userPrompt)
	if err != nil {
		return err
	}

	fmt.Printf("Added comment: %s\n", comment.HTMLURL)
	return nil
}

func runIssueAssign(cmd *cobra.Command, args []string) error {
	ctx := cmd.Context()

	number, err := strconv.Atoi(args[0])
	if err != nil {
		return fmt.Errorf("invalid issue number: %s", args[0])
	}

	assignees := args[1:]

	cfg, err := config.LoadFromWorkingDir()
	if err != nil {
		return err
	}

	ghClient, err := buildGitHubClient(cfg)
	if err != nil {
		return err
	}

	svc := service.NewIssueService(ghClient, nil, cfg)

	issue, err := svc.AssignIssue(ctx, number, assignees)
	if err != nil {
		return err
	}

	fmt.Printf("Assigned %v to issue #%d: %s\n", assignees, issue.Number, issue.HTMLURL)
	return nil
}

func runIssueLink(cmd *cobra.Command, args []string) error {
	ctx := cmd.Context()

	number, err := strconv.Atoi(args[0])
	if err != nil {
		return fmt.Errorf("invalid issue number: %s", args[0])
	}

	targetNumber, err := strconv.Atoi(args[1])
	if err != nil {
		return fmt.Errorf("invalid target issue number: %s", args[1])
	}

	cfg, err := config.LoadFromWorkingDir()
	if err != nil {
		return err
	}

	ghClient, err := buildGitHubClient(cfg)
	if err != nil {
		return err
	}

	svc := service.NewIssueService(ghClient, nil, cfg)

	if err := svc.LinkIssue(ctx, number, targetNumber, linkType); err != nil {
		return err
	}

	fmt.Printf("Linked issue #%d to #%d (%s)\n", number, targetNumber, linkType)
	return nil
}

func runIssueSub(cmd *cobra.Command, args []string) error {
	ctx := cmd.Context()

	parentNumber, err := strconv.Atoi(args[0])
	if err != nil {
		return fmt.Errorf("invalid parent issue number: %s", args[0])
	}

	cfg, err := config.LoadFromWorkingDir()
	if err != nil {
		return err
	}

	input := service.IssueInput{
		Title:       flagTitle,
		Description: flagDescription,
		Labels:      parseCSV(flagLabels),
		Assignees:   parseCSV(flagAssignees),
	}

	if len(args) > 1 {
		input.Prompt = strings.Join(args[1:], " ")
	}

	hasAnyInput := input.Prompt != "" || input.Title != "" || input.Description != ""
	if !hasAnyInput {
		input, err = runInteractiveMode(cfg)
		if err != nil {
			return err
		}
	}

	enhance := !flagRaw

	ghClient, err := buildGitHubClient(cfg)
	if err != nil {
		return err
	}

	var llmClient llm.Client
	if enhance {
		llmClient, err = buildLLMClient(cfg)
		if err != nil {
			return err
		}
		fmt.Println("Generating sub-issue...")
	}

	svc := service.NewIssueService(ghClient, llmClient, cfg)

	generated, err := svc.GenerateIssue(ctx, input, enhance)
	if err != nil {
		return err
	}

	printGeneratedIssue(generated, input.Assignees)
	fmt.Printf("Parent: #%d\n\n", parentNumber)

	if !flagYes {
		if !confirmAction("Create this sub-issue?") {
			fmt.Println("Aborted.")
			return nil
		}
	}

	issue, err := svc.CreateSubIssue(ctx, parentNumber, generated, input.Assignees)
	if err != nil {
		return err
	}

	fmt.Printf("Created sub-issue #%d: %s\n", issue.Number, issue.HTMLURL)
	return nil
}

func runIssueList(cmd *cobra.Command, args []string) error {
	ctx := cmd.Context()

	cfg, err := config.LoadFromWorkingDir()
	if err != nil {
		return err
	}

	ghClient, err := buildGitHubClient(cfg)
	if err != nil {
		return err
	}

	svc := service.NewIssueService(ghClient, nil, cfg)
	reader := bufio.NewReader(os.Stdin)
	page := flagPage

	for {
		req := github.ListIssuesRequest{
			State:    flagState,
			Assignee: flagAssignee,
			Labels:   flagLabel,
			PerPage:  flagLimit,
			Page:     page,
		}

		issues, err := svc.ListIssues(ctx, req)
		if err != nil {
			return err
		}

		if len(issues) == 0 && page == 1 {
			fmt.Println("No issues found.")
			return nil
		}

		if len(issues) == 0 {
			fmt.Println("No more issues.")
			return nil
		}

		printIssueList(issues)

		hasNext := len(issues) == flagLimit
		hasPrev := page > 1

		if !hasNext && !hasPrev {
			break
		}

		page = promptPagination(reader, page, hasNext, hasPrev)
		if page == 0 {
			break
		}

		fmt.Println()
	}

	return nil
}

func runIssueView(cmd *cobra.Command, args []string) error {
	ctx := cmd.Context()

	number, err := strconv.Atoi(args[0])
	if err != nil {
		return fmt.Errorf("invalid issue number: %s", args[0])
	}

	cfg, err := config.LoadFromWorkingDir()
	if err != nil {
		return err
	}

	ghClient, err := buildGitHubClient(cfg)
	if err != nil {
		return err
	}

	issue, err := ghClient.GetIssue(ctx, number)
	if err != nil {
		return err
	}

	if flagWeb {
		openInBrowser(issue.HTMLURL)
		fmt.Printf("Opening issue #%d in browser...\n", issue.Number)
		return nil
	}

	printIssueDetail(issue)
	return nil
}

func runIssueEdit(cmd *cobra.Command, args []string) error {
	ctx := cmd.Context()

	number, err := strconv.Atoi(args[0])
	if err != nil {
		return fmt.Errorf("invalid issue number: %s", args[0])
	}

	cfg, err := config.LoadFromWorkingDir()
	if err != nil {
		return err
	}

	ghClient, err := buildGitHubClient(cfg)
	if err != nil {
		return err
	}

	issue, err := ghClient.GetIssue(ctx, number)
	if err != nil {
		return err
	}

	input := buildEditInput(cmd)
	if input == nil {
		printIssueDetail(issue)
		fmt.Println("\nUse flags to specify changes: -t title, -d description, -l labels, -a assignees, -s state")
		return nil
	}

	enhance := flagEnhance && (input.Title != nil || input.Body != nil)

	var llmClient llm.Client
	if enhance {
		llmClient, err = buildLLMClient(cfg)
		if err != nil {
			return err
		}

		title := issue.Title
		if input.Title != nil {
			title = *input.Title
		}
		body := issue.Body
		if input.Body != nil {
			body = *input.Body
		}

		fmt.Println("Enhancing with LLM...")
		svcInput := service.IssueInput{
			Title:       title,
			Description: body,
		}
		svc := service.NewIssueService(ghClient, llmClient, cfg)
		generated, err := svc.GenerateIssue(ctx, svcInput, true)
		if err != nil {
			return err
		}
		input.Title = &generated.Title
		input.Body = &generated.Body
	}

	printEditPreview(issue, input)

	if !flagYes {
		if !confirmAction("Apply these changes?") {
			fmt.Println("Aborted.")
			return nil
		}
	}

	svc := service.NewIssueService(ghClient, nil, cfg)
	updated, err := svc.EditIssue(ctx, number, *input)
	if err != nil {
		return err
	}

	fmt.Printf("Updated issue #%d: %s\n", updated.Number, updated.HTMLURL)
	return nil
}

func buildEditInput(cmd *cobra.Command) *service.EditIssueInput {
	input := &service.EditIssueInput{}
	changed := false

	if cmd.Flags().Changed("title") {
		input.Title = &flagTitle
		changed = true
	}
	if cmd.Flags().Changed("description") {
		input.Body = &flagDescription
		changed = true
	}
	if cmd.Flags().Changed("state") {
		input.State = &flagState
		changed = true
	}
	if cmd.Flags().Changed("labels") {
		input.Labels = parseCSV(flagLabels)
		input.SetLabels = true
		changed = true
	}
	if cmd.Flags().Changed("assignees") {
		input.Assignees = parseCSV(flagAssignees)
		input.SetAssignees = true
		changed = true
	}

	if !changed {
		return nil
	}
	return input
}

func printEditPreview(current *github.Issue, input *service.EditIssueInput) {
	fmt.Println()
	fmt.Println(strings.Repeat("─", 60))
	fmt.Printf("Editing issue #%d\n", current.Number)
	fmt.Println(strings.Repeat("─", 60))

	if input.Title != nil {
		fmt.Printf("Title:      %s → %s\n", current.Title, *input.Title)
	}
	if input.Body != nil {
		body := truncate(*input.Body, 80)
		fmt.Printf("Body:       %s\n", body)
	}
	if input.State != nil {
		fmt.Printf("State:      %s → %s\n", current.State, *input.State)
	}
	if input.SetLabels {
		fmt.Printf("Labels:     %s → %s\n", formatLabels(current.Labels), strings.Join(input.Labels, ", "))
	}
	if input.SetAssignees {
		fmt.Printf("Assignees:  %s → %s\n", formatAssignees(current.Assignees), strings.Join(input.Assignees, ", "))
	}

	fmt.Println(strings.Repeat("─", 60))
}

func printIssueDetail(issue *github.Issue) {
	fmt.Println()
	fmt.Println(strings.Repeat("─", 60))
	fmt.Printf("#%d %s\n", issue.Number, issue.Title)
	fmt.Println(strings.Repeat("─", 60))
	fmt.Printf("State:      %s\n", issue.State)
	if len(issue.Labels) > 0 {
		fmt.Printf("Labels:     %s\n", formatLabels(issue.Labels))
	}
	if len(issue.Assignees) > 0 {
		fmt.Printf("Assignees:  %s\n", formatAssignees(issue.Assignees))
	}
	fmt.Printf("URL:        %s\n", issue.HTMLURL)
	fmt.Printf("Created:    %s\n", issue.CreatedAt.Format("2006-01-02 15:04"))
	fmt.Printf("Updated:    %s\n", issue.UpdatedAt.Format("2006-01-02 15:04"))
	fmt.Println(strings.Repeat("─", 60))
	if issue.Body != "" {
		fmt.Println(issue.Body)
	} else {
		fmt.Println("No description provided.")
	}
	fmt.Println(strings.Repeat("─", 60))
}

func openInBrowser(url string) {
	var cmd *exec.Cmd
	switch runtime.GOOS {
	case "darwin":
		cmd = exec.Command("open", url)
	case "linux":
		cmd = exec.Command("xdg-open", url)
	default:
		cmd = exec.Command("rundll32", "url.dll,FileProtocolHandler", url)
	}
	_ = cmd.Start()
}

func printIssueList(issues []github.Issue) {
	for _, issue := range issues {
		labels := formatLabels(issue.Labels)
		assignees := formatAssignees(issue.Assignees)

		line := fmt.Sprintf("#%-5d %-50s %-8s", issue.Number, truncate(issue.Title, 50), issue.State)
		if labels != "" {
			line += fmt.Sprintf(" %-12s", labels)
		}
		if assignees != "" {
			line += fmt.Sprintf(" %s", assignees)
		}
		fmt.Println(line)
		fmt.Printf("       %s\n", issue.HTMLURL)
	}
}

func promptPagination(reader *bufio.Reader, currentPage int, hasNext, hasPrev bool) int {
	fmt.Printf("\nPage %d", currentPage)

	var options []string
	if hasNext {
		options = append(options, "[n]ext")
	}
	if hasPrev {
		options = append(options, "[p]revious")
	}
	options = append(options, "[q]uit")

	fmt.Printf(" · %s: ", strings.Join(options, " · "))

	input, _ := reader.ReadString('\n')
	input = strings.ToLower(strings.TrimSpace(input))

	switch input {
	case "n":
		if hasNext {
			return currentPage + 1
		}
	case "p":
		if hasPrev {
			return currentPage - 1
		}
	}
	return 0
}

func formatLabels(labels []github.Label) string {
	names := make([]string, len(labels))
	for i, l := range labels {
		names[i] = l.Name
	}
	return strings.Join(names, ",")
}

func formatAssignees(users []github.User) string {
	names := make([]string, len(users))
	for i, u := range users {
		names[i] = u.Login
	}
	return strings.Join(names, ",")
}

func truncate(s string, maxLen int) string {
	if len(s) <= maxLen {
		return s
	}
	return s[:maxLen-3] + "..."
}

func buildGitHubClient(cfg *config.Config) (github.Client, error) {
	store := config.NewCompositeTokenStore()
	token, err := store.Get(config.ProjectKey(cfg))
	if err != nil {
		return nil, fmt.Errorf("not authenticated: %w\nrun 'grit auth login' first", err)
	}
	return github.NewHTTPClient(cfg.Project.Owner, cfg.Project.Repo, token), nil
}

func buildLLMClient(cfg *config.Config) (llm.Client, error) {
	var apiKey string
	if cfg.LLM.Provider != "ollama" {
		var err error
		apiKey, err = config.GetLLMKey(cfg.LLM.Provider)
		if err != nil {
			return nil, err
		}
	}
	return llm.NewClient(cfg.LLM, apiKey)
}

func printGeneratedIssue(issue *llm.GeneratedIssue, assignees []string) {
	fmt.Println()
	fmt.Println(strings.Repeat("─", 60))
	fmt.Printf("Title: %s\n", issue.Title)
	fmt.Println(strings.Repeat("─", 60))
	fmt.Println(issue.Body)
	fmt.Println(strings.Repeat("─", 60))
	if len(issue.Labels) > 0 {
		fmt.Printf("Labels: %s\n", strings.Join(issue.Labels, ", "))
	}
	if len(assignees) > 0 {
		fmt.Printf("Assignees: %s\n", strings.Join(assignees, ", "))
	}
	fmt.Println()
}

func confirmAction(prompt string) bool {
	reader := bufio.NewReader(os.Stdin)
	fmt.Printf("%s [Y/n]: ", prompt)
	response, _ := reader.ReadString('\n')
	response = strings.ToLower(strings.TrimSpace(response))
	return response == "" || response == "y" || response == "yes"
}

func promptOptional(reader *bufio.Reader, label string) (string, error) {
	fmt.Printf("%s: ", label)
	input, err := reader.ReadString('\n')
	if err != nil {
		return "", fmt.Errorf("reading input: %w", err)
	}
	return strings.TrimSpace(input), nil
}

func parseCSV(s string) []string {
	if s == "" {
		return nil
	}
	parts := strings.Split(s, ",")
	var result []string
	for _, p := range parts {
		p = strings.TrimSpace(p)
		if p != "" {
			result = append(result, p)
		}
	}
	return result
}

func validateLabels(requested, allowed []string) []string {
	if len(allowed) == 0 {
		return requested
	}

	allowedSet := make(map[string]bool)
	for _, l := range allowed {
		allowedSet[strings.ToLower(l)] = true
	}

	var valid []string
	var invalid []string
	for _, l := range requested {
		if allowedSet[strings.ToLower(l)] {
			valid = append(valid, l)
		} else {
			invalid = append(invalid, l)
		}
	}

	if len(invalid) > 0 {
		fmt.Printf("Warning: invalid labels ignored: %s\n", strings.Join(invalid, ", "))
		fmt.Printf("Allowed labels: %s\n", strings.Join(allowed, ", "))
	}

	return valid
}
